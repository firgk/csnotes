

## 正则表达式
正则表达式是用来匹配字符或者字符串的工具 独立于编程语言


匹配一组字符中的一个
`[ ]`定义一个字符集合
`-` 区间
`^` 非

  匹配以 abc 为开头，并且最后一个字母不为数字的字符串
  `abc[^0-9]`


单个字符匹配

  大写是取非


`.` 匹配任何一个字符
匹配 `.` 要用 `\` 进行转义


数字元字符
`\d -> [0-9]`
`\D -> [^0-9]`




字母数字元字符
`\w -> 大小写字母 下划线和数字，等价于[a-zA-Z0-9\_]`
`\W -> 对 \w 取非`


进制级别
`\x `匹配十六进制字符  例如 `\xA` 对应值为 10 的 ASCII 字符  即 `\n`
`\0 `匹配八进制



空白字符 : 不是可见的字符 比如tab 回车等
```
|  \b | 回退（删除）一个字符   |
|  \f |  换页符 |
|  \n |  换行符 |
|  \r |  回车符 |
|  \t |  制表符 |
|  \v |  垂直制表符 |
```
`\r\n` 是 Windows 中的文本行结束标签，在 Unix/Linux 则是 \n。
`\r\n\r\n` 可以匹配 Windows 下的空白行，因为它匹配两个连续的行尾标签，而这正是两条记录之间的空白行；


`\s 任何一个空白字符，等价于 [\f\n\r\t\v]`
`\S 对 \s 取非`




重复匹配
```
?   匹配 0 个或者 1 个字符
+   匹配 1 个或者多个字符
*   匹配 0 个或者多个字符

  辅助记忆
  ? 是否 只有0 或者1
  * 无限可能
  + 比无限可能少一点
  ? 和 + 在一起正好是 *


{n} 匹配 n 个字符
{m,n} 匹配 m\~n 个字符
{m,} 至少匹配 m 个字符
```

匹配邮箱地址。
`[\w.]+@\w+\.\w+`
`*` 和 `+` 都是贪婪型元字符，会匹配尽可能多的内容。在后面加 `?` 可以转换为懒惰型元字符，例如 `*?`、`+?` 和 `{m,n}?` 。



位置匹配

单词边界
`\b` 可以匹配一个单词的边界
`\B` 匹配一个不是单词边界的位置
\babc\b 匹配出来的结果为 3 个字符

字符串边界
`^` 匹配整个字符串的开头
`$` 匹配结尾。

`多行匹配`模式（multiline）下，换行被当做字符串的边界。
```
Line 1
Line 2
Line 3
```
如果使用正则表达式 ^Line 进行匹配，只有第一行会匹配成功。但如果启用了多行匹配模式，正则表达式 ^Line 将会匹配每一行的开头。
匹配代码中以 // 开始的注释行
```
^\s*\/\/.*$
```




高阶

使用子表达式
使用 `()` 定义一个子表达式
可以看成一个独立元素
`(ab){2,}` -> `ababab`
`|` 是或
`(19|20)\d{2}`

匹配 IP 地址。
```
IP 地址中每部分都是 0-255 的数字，用正则表达式匹配时以下情况是合法的：
一位数字a
不以 0 开头的两位数字
1 开头的三位数
2 开头，第 2 位是 0-4 的三位数
25 开头，第 3 位是 0-5 的三位数
```
```
((25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))\.){3}(25[0-5]|(2[0-4]\d)|(1\d{2})|([1-9]\d)|(\d))
```




回溯引用
前后查找
嵌入条件

